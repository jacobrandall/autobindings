package main

var bindingsFileTitle = `package {{.packageName}}
/*
This is an autogenerated file by autobindings
*/

import(
	"encoding/json"
  "fmt"
  "github.com/awslabs/aws-sdk-go/aws"
  "github.com/awslabs/aws-sdk-go/service/dynamodb"
	"github.com/mholt/binding"
)

type {{.structName}}Create struct {
	{{range $field, $mapping := .mappings}}{{if eq $mapping.Create true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}
}

type {{.structName}}Update struct {
	{{range $field, $mapping := .mappings}}{{if eq $mapping.Update true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}
}

func ({{.variableName}} *{{.structName}}Create) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := .variableName}}{{range $field, $mapping := .mappings}}{{if eq $mapping.Create true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}
	}
}

func (t {{.structName}}Create) String() string {
	jb, err := json.Marshal(t)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (t {{.structName}}Create) Create() {

}

func (t *{{.structName}}Create) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := .mappings}}{{if eq $mapping.Create true }}
    if t.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*t.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *t.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *t.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*t.{{$field}})} {{end}}
    }{{end}}{{end}}
  return &m
}

func (ts *{{.structName}}Create) FromDynamoMap(m *map[string]dynamodb.AttributeValue) (*Title, error) {
  t := &Title{}
  {{range $field, $mapping := .mappings}} {{if eq $mapping.Create true }}
    {{if eq $mapping.Type "*string"}}
      if (*m)["{{$field}}"].S != nil {
      t.{{$field}} = (*m)["{{$field}}"].S {{else if eq $mapping.Type "*int64"}}
      if (*m)["{{$field}}"].N != nil {
      i, err := strconv.ParseInt(*((*m)["{{$field}}"].N), 10, 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Int64")
  		}
  		t.{{$field}} = &i {{else if eq $mapping.Type "*float64"}}
      if (*m)["{{$field}}"].N != nil {
      f, err := strconv.ParseFloat(*((*m)["{{$field}}"].N), 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Float64")
  		}
  		t.{{$field}} = &f {{else if eq $mapping.Type "*bool"}}
      if (*m)["{{$field}}"].BOOL != nil {
        t.{{$field}} = (*m)["{{$field}}"].BOOL {{end}}
    }{{end}}{{end}}
  return t, nil
}

func ({{.variableName}} *{{.structName}}Update) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := .variableName}}{{range $field, $mapping := .mappings}}{{if eq $mapping.Update true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}
	}
}

func (t {{.structName}}Update) String() string {
	jb, err := json.Marshal(t)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (t {{.structName}}Update) Update() {

}

func (a *{{.structName}}Update) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := .mappings}}{{if eq $mapping.Update true }}
    if a.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*a.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*a.{{$field}})} {{end}}
    }{{end}}{{end}}
  return &m
}

func (ts *{{.structName}}Update) FromDynamoMap(m *map[string]dynamodb.AttributeValue) (*Title, error) {
  t := &Title{}
  {{range $field, $mapping := .mappings}} {{if eq $mapping.Update true }}
    {{if eq $mapping.Type "*string"}}
      if (*m)["{{$field}}"].S != nil {
      t.{{$field}} = (*m)["{{$field}}"].S {{else if eq $mapping.Type "*int64"}}
      if (*m)["{{$field}}"].N != nil {
      i, err := strconv.ParseInt(*((*m)["{{$field}}"].N), 10, 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Int64")
  		}
  		t.{{$field}} = &i {{else if eq $mapping.Type "*float64"}}
      if (*m)["{{$field}}"].N != nil {
      f, err := strconv.ParseFloat(*((*m)["{{$field}}"].N), 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Float64")
  		}
  		t.{{$field}} = &f {{else if eq $mapping.Type "*bool"}}
      if (*m)["{{$field}}"].BOOL != nil {
        t.{{$field}} = (*m)["{{$field}}"].BOOL {{end}}
    }{{end}}{{end}}
  return t, nil
}

`

var bindingsFileAsset = `package {{.packageName}}
/*
This is an autogenerated file by autobindings
*/

import(
	"encoding/json"
  "fmt"
  "github.com/awslabs/aws-sdk-go/aws"
  "github.com/awslabs/aws-sdk-go/service/dynamodb"
	"github.com/mholt/binding"
)

{{ $root := . }}

{{range $mediaType := .mediaTypes}}
type {{$root.structName}}{{$mediaType}}Create struct {
	{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Create true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}{{end}}
}

type {{$root.structName}}{{$mediaType}}Update struct {
	{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Update true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}{{end}}
}

func ({{$root.variableName}} *{{$root.structName}}{{$mediaType}}Create) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := $root.variableName}}{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Create true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}{{end}}
	}
}

func (a {{$root.structName}}{{$mediaType}}Create) String() string {
	jb, err := json.Marshal(a)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (a *{{$root.structName}}{{$mediaType}}Create) Create() {

}

func (a *{{$root.structName}}{{$mediaType}}Create) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Create true }}
    if a.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*a.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*a.{{$field}})} {{end}}
    }{{end}}{{end}}{{end}}
  return &m
}

func (as *{{$root.structName}}{{$mediaType}}Create) FromDynamoMap(m *map[string]dynamodb.AttributeValue) (*Asset, error) {
  a := &Asset{}
  {{range $field, $mapping := $root.mappings}} {{if $mapping.HasMediaType $mediaType}} {{if eq $mapping.Create true }}
    {{if eq $mapping.Type "*string"}}
      if (*m)["{{$field}}"].S != nil {
      a.{{$field}} = (*m)["{{$field}}"].S {{else if eq $mapping.Type "*int64"}}
      if (*m)["{{$field}}"].N != nil {
      i, err := strconv.ParseInt(*((*m)["{{$field}}"].N), 10, 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Int64")
  		}
  		a.{{$field}} = &i {{else if eq $mapping.Type "*float64"}}
      if (*m)["{{$field}}"].N != nil {
      f, err := strconv.ParseFloat(*((*m)["{{$field}}"].N), 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Float64")
  		}
  		a.{{$field}} = &f {{else if eq $mapping.Type "*bool"}}
      if (*m)["{{$field}}"].BOOL != nil {
        a.{{$field}} = (*m)["{{$field}}"].BOOL {{end}}
    }{{end}}{{end}}{{end}}
  return a, nil
}

func ({{$root.variableName}} *{{$root.structName}}{{$mediaType}}Update) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := $root.variableName}}{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Update true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}{{end}}
	}
}

func (a {{$root.structName}}{{$mediaType}}Update) String() string {
	jb, err := json.Marshal(a)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (a *{{$root.structName}}{{$mediaType}}Update) Update() {

}

func (a *{{$root.structName}}{{$mediaType}}Update) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Update true }}
    if a.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*a.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*a.{{$field}})} {{end}}
    }{{end}}{{end}}{{end}}
  return &m
}

func (as *{{$root.structName}}{{$mediaType}}Update) FromDynamoMap(m *map[string]dynamodb.AttributeValue) (*Asset, error) {
  a := &Asset{}
  {{range $field, $mapping := $root.mappings}} {{if $mapping.HasMediaType $mediaType}} {{if eq $mapping.Update true }}
    {{if eq $mapping.Type "*string"}}
      if (*m)["{{$field}}"].S != nil {
      a.{{$field}} = (*m)["{{$field}}"].S {{else if eq $mapping.Type "*int64"}}
      if (*m)["{{$field}}"].N != nil {
      i, err := strconv.ParseInt(*((*m)["{{$field}}"].N), 10, 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Int64")
  		}
  		a.{{$field}} = &i {{else if eq $mapping.Type "*float64"}}
      if (*m)["{{$field}}"].N != nil {
      f, err := strconv.ParseFloat(*((*m)["{{$field}}"].N), 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Float64")
  		}
  		a.{{$field}} = &f {{else if eq $mapping.Type "*bool"}}
      if (*m)["{{$field}}"].BOOL != nil {
        a.{{$field}} = (*m)["{{$field}}"].BOOL {{end}}
    }{{end}}{{end}}{{end}}
  return a, nil
}

{{end}}
`

/*
func dynamoMapToAssetModel(m *map[string]dynamodb.AttributeValue) (*models.Asset, error) {
	a := &models.Asset{}
	if (*m)["Id"].S != nil {
		a.Id = (*m)["Id"].S
	}
	if (*m)["TitleId"].S != nil {
		a.TitleId = (*m)["TitleId"].S
	}
	if (*m)["CreatedAt"].S != nil {
		a.CreatedAt = (*m)["CreatedAt"].S
	}
	if (*m)["UpdatedAt"].S != nil {
		a.UpdatedAt = (*m)["UpdatedAt"].S
	}
	if (*m)["MediaType"].S != nil {
		a.MediaType = (*m)["MediaType"].S
	}
	if (*m)["Variant"].S != nil {
		a.Variant = (*m)["Variant"].S
	}
	if (*m)["Duration"].N != nil {
		sd, err := strconv.ParseInt(*((*m)["Duration"].N), 10, 64)
		if err != nil {
			return nil, ErrAssetConvertDurationAtStringUint
		}
		ud := uint(sd)
		a.Duration = &ud
	}
	if (*m)["MediaURL"].S != nil {
		a.MediaURL = (*m)["MediaURL"].S
	}
	if (*m)["AtomMapURL"].S != nil {
		a.AtomMapURL = (*m)["AtomMapURL"].S
	}
	if (*m)["Width"].N != nil {
		width, err := strconv.ParseInt(*((*m)["Width"].N), 10, 64)
		if err != nil {
			return nil, ErrAssetConvertWidthStringInt
		}
		a.Width = &width
	}
	if (*m)["Height"].N != nil {
		height, err := strconv.ParseInt(*((*m)["Height"].N), 10, 64)
		if err != nil {
			return nil, ErrAssetConvertHeightStringInt
		}
		a.Height = &height
	}
	if (*m)["FrameRate"].N != nil {
		frameRate, err := strconv.ParseFloat(*((*m)["FrameRate"].N), 64)
		if err != nil {
			return nil, ErrAssetConvertFrameRateStringFloat64
		}
		a.FrameRate = &frameRate
	}
	if (*m)["GopInterval"].N != nil {
		gopInterval, err := strconv.ParseInt(*((*m)["GopInterval"].N), 10, 64)
		if err != nil {
			return nil, ErrAssetConvertGopIntervalStringInt
		}
		a.GopInterval = &gopInterval
	}
	if (*m)["SampleRate"].N != nil {
		//sampleRate, err := strconv.ParseInt(s, 10, 64)
		sampleRate, err := strconv.ParseInt(*((*m)["SampleRate"].N), 10, 64)
		if err != nil {
			return nil, ErrAssetConvertSampleRateStringInt
		}
		a.SampleRate = &sampleRate
	}
	if (*m)["AudioConfig"].S != nil {
		a.AudioConfig = (*m)["AudioConfig"].S
	}
	if (*m)["Bitrate"].N != nil {
		bitrate, err := strconv.ParseInt(*((*m)["Bitrate"].N), 10, 64)
		if err != nil {
			return nil, ErrAssetConvertBitRateStringInt
		}
		a.Bitrate = &bitrate
	}
	if (*m)["Codec"].S != nil {
		a.Codec = (*m)["Codec"].S
	}
	if (*m)["Profile"].S != nil {
		a.Profile = (*m)["Profile"].S
	}
	if (*m)["FragRate"].N != nil {
		fragRate, err := strconv.ParseInt(*((*m)["FragRate"].N), 10, 64)
		if err != nil {
			return nil, ErrAssetConvertFragRateStringInt
		}
		a.FragRate = &fragRate
	}
	if (*m)["Language"].S != nil {
		a.Language = (*m)["Language"].S
	}
	if (*m)["Dialect"].S != nil {
		a.Dialect = (*m)["Dialect"].S
	}
	return a, nil
}
*/

var baseFieldMap = `func ({{.variableName}} *{{.structName}}) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := .variableName}}{{range $field, $mapping := .mappings}}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}
	}
}`
