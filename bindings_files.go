package main

var bindingsFileTitle = `package {{.packageName}}
/*
This is an autogenerated file by autobindings
*/

import(
	"encoding/json"
  "fmt"
  "github.com/awslabs/aws-sdk-go/aws"
  "github.com/awslabs/aws-sdk-go/service/dynamodb"
	"github.com/mholt/binding"
)

type {{.structName}}Create struct {
	{{range $field, $mapping := .mappings}}{{if eq $mapping.Create true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}
}

var _ {{.structName}}Creater = (*{{.structName}}Create)(nil) // Forces compile time checking of the interface

type {{.structName}}Update struct {
	{{range $field, $mapping := .mappings}}{{if eq $mapping.Update true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}
}

var _ {{.structName}}Updater = (*{{.structName}}Update)(nil) // Forces compile time checking of the interface

func ({{.variableName}} *{{.structName}}Create) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := .variableName}}{{range $field, $mapping := .mappings}}{{if eq $mapping.Create true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}
	}
}

func (t {{.structName}}Create) String() string {
	jb, err := json.Marshal(t)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (t {{.structName}}Create) Create() {

}

func (t *{{.structName}}Create) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := .mappings}}{{if eq $mapping.Create true }}
    if t.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*t.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *t.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *t.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*t.{{$field}})} {{end}}
    }{{end}}{{end}}
  return &m
}

func ({{.variableName}} *{{.structName}}Update) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := .variableName}}{{range $field, $mapping := .mappings}}{{if eq $mapping.Update true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}
	}
}

func (t {{.structName}}Update) String() string {
	jb, err := json.Marshal(t)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (t {{.structName}}Update) Update() {

}

func (a {{.structName}}Update) Validate(req *http.Request, errs binding.Errors) binding.Errors {
	var fieldsProvided bool = false
	{{range $field, $mapping := .mappings}}{{if eq $mapping.Update true }}
	if a.{{$field}} != nil {
			fieldsProvided = true
	}{{end}}{{end}}
  if fieldsProvided == false {
      errs = append(errs, binding.Error{
          FieldNames:     []string{},
          Classification: "NoFieldsProvidedError",
          Message:        "No valid fields have been provided",
      })
  }
  return errs
}


func (a *{{.structName}}Update) ToDynamoMap() *map[string]dynamodb.AttributeValueUpdate {
  m := make(map[string]dynamodb.AttributeValueUpdate)
  {{range $field, $mapping := .mappings}}{{if eq $mapping.Update true }}
    if a.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{S: aws.String(*a.{{$field}})}} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))}} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))}} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{BOOL: aws.Boolean(*a.{{$field}})}} {{end}}
    }{{end}}{{end}}
  return &m
}

func (t *{{.structName}}) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := .mappings}}
    if t.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*t.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *t.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *t.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*t.{{$field}})} {{end}}
    }{{end}}
  return &m
}

func {{.structName}}FromDynamoMap(m *map[string]dynamodb.AttributeValue) (*Title, error) {
  t := &Title{}
  {{range $field, $mapping := .mappings}}
    {{if eq $mapping.Type "*string"}}
      if (*m)["{{$field}}"].S != nil {
      t.{{$field}} = (*m)["{{$field}}"].S {{else if eq $mapping.Type "*int64"}}
      if (*m)["{{$field}}"].N != nil {
      i, err := strconv.ParseInt(*((*m)["{{$field}}"].N), 10, 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Int64")
  		}
  		t.{{$field}} = &i {{else if eq $mapping.Type "*float64"}}
      if (*m)["{{$field}}"].N != nil {
      f, err := strconv.ParseFloat(*((*m)["{{$field}}"].N), 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Float64")
  		}
  		t.{{$field}} = &f {{else if eq $mapping.Type "*bool"}}
      if (*m)["{{$field}}"].BOOL != nil {
        t.{{$field}} = (*m)["{{$field}}"].BOOL {{end}}
    }{{end}}
  return t, nil
}

`

var bindingsFileAsset = `package {{.packageName}}
/*
This is an autogenerated file by autobindings
*/

import(
	"encoding/json"
  "fmt"
  "github.com/awslabs/aws-sdk-go/aws"
  "github.com/awslabs/aws-sdk-go/service/dynamodb"
	"github.com/mholt/binding"
)

{{ $root := . }}

{{range $mediaType := .mediaTypes}}
type {{$root.structName}}{{$mediaType}}Create struct {
	{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Create true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}{{end}}
}

var _ {{$root.structName}}Creater = (*{{$root.structName}}{{$mediaType}}Create)(nil) // Forces compile time checking of the interface

type {{$root.structName}}{{$mediaType}}Update struct {
	{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Update true }}
	{{$field}} {{$mapping.Type}} {{$mapping.RestrictedTags}}{{end}}{{end}}{{end}}
}

var _ {{$root.structName}}Updater = (*{{$root.structName}}{{$mediaType}}Update)(nil) // Forces compile time checking of the interface

func ({{$root.variableName}} *{{$root.structName}}{{$mediaType}}Create) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := $root.variableName}}{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Create true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}{{end}}
	}
}

func (a {{$root.structName}}{{$mediaType}}Create) String() string {
	jb, err := json.Marshal(a)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (a *{{$root.structName}}{{$mediaType}}Create) Create() {

}

func (a *{{$root.structName}}{{$mediaType}}Create) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Create true }}
    if a.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*a.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*a.{{$field}})} {{end}}
    }{{end}}{{end}}{{end}}
  return &m
}

func ({{$root.variableName}} *{{$root.structName}}{{$mediaType}}Update) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := $root.variableName}}{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Update true }}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}{{end}}{{end}}
	}
}

func (a {{$root.structName}}{{$mediaType}}Update) String() string {
	jb, err := json.Marshal(a)
	if err != nil {
		return ""
	}
	return string(jb)
}

func (a *{{$root.structName}}{{$mediaType}}Update) Update() {

}

func (a {{$root.structName}}{{$mediaType}}Update) Validate(req *http.Request, errs binding.Errors) binding.Errors {
	var fieldsProvided bool = false
	{{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Update true }}
	if a.{{$field}} != nil {
			fieldsProvided = true
	}{{end}}{{end}}{{end}}
  if fieldsProvided == false {
      errs = append(errs, binding.Error{
          FieldNames:     []string{},
          Classification: "NoFieldsProvidedError",
          Message:        "No valid fields have been provided",
      })
  }
  return errs
}

func (a *{{$root.structName}}{{$mediaType}}Update) ToDynamoMap() *map[string]dynamodb.AttributeValueUpdate {
  m := make(map[string]dynamodb.AttributeValueUpdate)
  {{range $field, $mapping := $root.mappings}}{{if $mapping.HasMediaType $mediaType}}{{if eq $mapping.Update true }}
    if a.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{S: aws.String(*a.{{$field}})}} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))}} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))}} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValueUpdate{Action: aws.String("PUT"), Value: &dynamodb.AttributeValue{BOOL: aws.Boolean(*a.{{$field}})}} {{end}}
    }{{end}}{{end}}{{end}}
  return &m
}

{{end}}

func (a *{{$root.structName}}) ToDynamoMap() *map[string]dynamodb.AttributeValue {
  m := make(map[string]dynamodb.AttributeValue)
  {{range $field, $mapping := $root.mappings}}
    if a.{{$field}} != nil { {{if eq $mapping.Type "*string"}}
      m["{{$field}}"] = dynamodb.AttributeValue{S: aws.String(*a.{{$field}})} {{else if eq $mapping.Type "*int64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*float64"}}
      m["{{$field}}"] = dynamodb.AttributeValue{N: aws.String(fmt.Sprintf("%v", *a.{{$field}}))} {{else if eq $mapping.Type "*bool"}}
      m["{{$field}}"] = dynamodb.AttributeValue{BOOL: aws.Boolean(*a.{{$field}})} {{end}}
    }{{end}}
  return &m
}

func {{$root.structName}}FromDynamoMap(m *map[string]dynamodb.AttributeValue) (*Asset, error) {
  a := &Asset{}
  {{range $field, $mapping := $root.mappings}}
    {{if eq $mapping.Type "*string"}}
      if (*m)["{{$field}}"].S != nil {
      a.{{$field}} = (*m)["{{$field}}"].S {{else if eq $mapping.Type "*int64"}}
      if (*m)["{{$field}}"].N != nil {
      i, err := strconv.ParseInt(*((*m)["{{$field}}"].N), 10, 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Int64")
  		}
  		a.{{$field}} = &i {{else if eq $mapping.Type "*float64"}}
      if (*m)["{{$field}}"].N != nil {
      f, err := strconv.ParseFloat(*((*m)["{{$field}}"].N), 64)
  		if err != nil {
  			return nil, NewConvertError("{{$field}}", "String", "Float64")
  		}
  		a.{{$field}} = &f {{else if eq $mapping.Type "*bool"}}
      if (*m)["{{$field}}"].BOOL != nil {
        a.{{$field}} = (*m)["{{$field}}"].BOOL {{end}}
    }{{end}}
  return a, nil
}

`

var baseFieldMap = `func ({{.variableName}} *{{.structName}}) FieldMap() binding.FieldMap {
	return binding.FieldMap{ {{$vname := .variableName}}{{range $field, $mapping := .mappings}}
			&{{$vname}}.{{$field}}: binding.Field{
				Form:"{{$mapping.JSONTags}}",
				Required: {{$mapping.Required}},
			},{{end}}
	}
}`
